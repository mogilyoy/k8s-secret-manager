/*
Copyright © 2025 NAME HERE <EMAIL ADDRESS>
*/
package cmd

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/mogilyoy/k8s-secret-manager/internal/api"
	"github.com/spf13/cobra"
)

var (
	createName      string
	createNamespace string
	createType      string
	createDataFile  string
	createDataKeys  []string
	createLength    int
	createEncoding  string
)

// createCmd represents the create command
var createCmd = &cobra.Command{
	Use:     "create NAME",
	Aliases: []string{"add", "new"},
	Short:   "Create a new SecretClaim resource",
	Long: `Creates a new SecretClaim resource in the API. Requires the resource name and type. 
Type can be 'Opaque' (for passing static data) or 'AutoGenerated' (for dynamic generation).`,
	Example: `# Create an Opaque secret with data from a file
  ./ksec create my-db-secret --type Opaque -n staging --data-file ./secret-data.json

  # Create an AutoGenerated secret
  ./ksec create my-password-secret --type AutoGenerated --length 32 --encoding alphanumeric --keys '["db_pass","db_login"]'`,
	Args: cobra.ExactArgs(1),
	RunE: runCreateSecret,
}

func init() {
	rootCmd.AddCommand(createCmd)

	createCmd.Flags().StringVarP(&createType, "type", "", "", "Secret type: Opaque or AutoGenerated")
	createCmd.Flags().StringVarP(&createNamespace, "namespace", "n", "default", "Target Kubernetes namespace")

	createCmd.Flags().StringVarP(&createDataFile, "data-file", "f", "", "Path to a JSON file with 'data' or 'generationConfig'")

	createCmd.Flags().IntVarP(&createLength, "length", "l", 0, "Length of the generated secret (if type=AutoGenerated)")
	createCmd.Flags().StringVar(&createEncoding, "encoding", "alphanumeric", "Encoding for the generated secret (symbols, digits, alphanumeric)")
	createCmd.Flags().StringSliceVarP(&createDataKeys, "key", "k", []string{}, "Keys to generate (comma-separated: db_pass,db_user)")
	createCmd.MarkFlagRequired("type")
}

func runCreateSecret(cmd *cobra.Command, args []string) error {
	createName = args[0]

	if createType != "Opaque" && createType != "AutoGenerated" {
		return fmt.Errorf("invalid secret type: %s. Must be 'Opaque' or 'AutoGenerated'", createType)
	}

	req := api.CreateSecretRequest{
		Name:      createName,
		Namespace: createNamespace,
		Type:      api.CreateSecretRequestType(createType),
	}

	hasGenerationFlags := createLength != 0 || createEncoding != "" || len(createDataKeys) > 0
	if createType == "Opaque" && hasGenerationFlags {
		return fmt.Errorf("generation flags (--length, --key, --encoding) are only valid for AutoGenerated type")
	}

	switch createType {
	case "Opaque":
		if createDataFile != "" {
			dataMap, err := readDataFromFile(createDataFile)
			if err != nil {
				return err
			}
			req.Data = &dataMap
		} else {
			emptyMap := make(map[string]string)
			req.Data = &emptyMap
		}

	case "AutoGenerated":

		var dataKeys []string
		if len(createDataKeys) > 0 {
			dataKeys = createDataKeys
		} else {
			return fmt.Errorf("at least one --key required for AutoGenerated")
		}

		for i, key := range dataKeys {
			dataKeys[i] = strings.TrimSpace(key)
			if dataKeys[i] == "" {
				return fmt.Errorf("empty key not allowed")
			}
		}

		var genConfig api.GenerationConfig

		if createDataFile != "" {
			localConfig, err := readGenerationConfigFromFile(createDataFile)
			if err != nil {
				return err
			}

			genConfig = api.GenerationConfig{
				Length:   int32(localConfig.Length),
				Encoding: localConfig.Encoding,
				DataKeys: &dataKeys,
			}

		} else {
			if createLength == 0 {
				return fmt.Errorf("flag --length is required for type AutoGenerated")
			}
			if createLength < 8 {
				return fmt.Errorf("generation length must be at least 8")
			}
			if createDataFile != "" {
				fmt.Println("Warning: Reading GenerationConfig from file is not fully implemented yet.")
			}
			if createEncoding == "" {
				return fmt.Errorf("flag --encoding is required for type AutoGenerated")
			}
			generationEncoding := api.GenerationConfigEncoding(createEncoding)
			genConfig = api.GenerationConfig{
				Length:   int32(createLength),
				Encoding: &generationEncoding,
				DataKeys: &dataKeys,
			}
			req.GenerationConfig = &genConfig
		}

	}

	if token == "" {
		return fmt.Errorf("authentication token is missing. Please run 'ksec login' first")
	}

	reqBody, err := json.Marshal(req)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %w", err)
	}

	createURL := fmt.Sprintf("%s/secrets", serverURL)

	httpReq, err := http.NewRequest("POST", createURL, bytes.NewBuffer(reqBody))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	httpReq.Header.Set("Content-Type", "application/json")
	responseBytes, statusCode, err := doAPIRequest(httpReq)
	if err != nil {
		return err
	}

	if statusCode != http.StatusOK && statusCode != http.StatusCreated {
		var errResp ErrorResponse
		if json.Unmarshal(responseBytes, &errResp) == nil {
			return fmt.Errorf("API call failed with unexpected status: %d %s", statusCode, http.StatusText(statusCode))
		}
		return fmt.Errorf("API call failed (Status: %d, Code: %s): %s", errResp.StatusCode, errResp.ErrorCode, errResp.ErrorMessage)
	}

	var successResponse api.OkResponse
	if err := json.Unmarshal(responseBytes, &successResponse); err != nil {
		return fmt.Errorf("failed to decode successful response (Status %d): %w", statusCode, err)
	}

	fmt.Printf("✅ SecretClaim '%s/%s' created successfully (Status: %d %s).\n",
		createNamespace, createName, statusCode, http.StatusText(statusCode))

	return nil
}
