/*
Copyright © 2025 NAME HERE <EMAIL ADDRESS>
*/
package cmd

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/mogilyoy/k8s-secret-manager/internal/api"
	"github.com/spf13/cobra"
)

var getNamespace string
var getSecretName string

var getCmd = &cobra.Command{
	Use:   "get NAME",
	Short: "Get full details of a SecretClaim resource",
	Long: `Retrieves the full specification and current status, including secret data 
(if synchronized), for a specific SecretClaim resource by its name.`,
	Example: `  ksec get my-db-secret -n staging`,
	Args:    cobra.ExactArgs(1),
	RunE:    runGetSecret,
}

func init() {
	rootCmd.AddCommand(getCmd)

	getCmd.Flags().StringVarP(&getNamespace, "namespace", "n", "", "Target Kubernetes namespace (required)")

	getCmd.MarkFlagRequired("namespace")
}

func runGetSecret(cmd *cobra.Command, args []string) error {
	getSecretName = args[0]

	if token == "" {
		return fmt.Errorf("authentication token is missing. Please run 'ksec login' first or provide --token flag")
	}

	getURL := fmt.Sprintf("%s/secrets/%s?namespace=%s", serverURL, getSecretName, getNamespace)

	httpReq, err := http.NewRequest("GET", getURL, nil)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	responseBytes, statusCode, err := doAPIRequest(httpReq)
	if err != nil {
		return err
	}

	if statusCode != http.StatusOK {
		var errResp ErrorResponse
		if json.Unmarshal(responseBytes, &errResp) == nil {
			return fmt.Errorf("API call failed (Status: %d, Code: %s): %s", errResp.StatusCode, errResp.ErrorCode, errResp.ErrorMessage)
		}
		return fmt.Errorf("API call failed with unexpected status: %d %s", statusCode, http.StatusText(statusCode))
	}

	var successResponse api.SecretResponse
	if err := json.Unmarshal(responseBytes, &successResponse); err != nil {
		return fmt.Errorf("failed to decode successful response (Status %d): %w", statusCode, err)
	}

	printSecretDetails(successResponse)

	return nil
}

// printSecretDetails форматирует и выводит полные детали секрета
func printSecretDetails(s api.SecretResponse) {
	fmt.Println("\n--- Secret Details ---")

	namespace := *s.Namespace
	fmt.Printf("Name:        %s\n", s.Name)
	fmt.Printf("Namespace:   %s\n", namespace)
	fmt.Printf("Type:        %s\n", s.Type)
	fmt.Printf("UID:         %s\n", *s.Uid)
	fmt.Printf("Created At:  %s\n", formatTimestamp(s.CreationTimestamp.String()))

	// Статус
	fmt.Println("\n--- Status ---")
	fmt.Printf("Current Status: %s\n", s.Status.CurrentStatus)
	fmt.Printf("Synced:         %t\n", s.Status.Synced)
	if s.Status.Synced {
		secretName := *s.Status.SecretName
		fmt.Printf("K8s Secret Name: %s\n", secretName)
		fmt.Printf("Last Sync:       %s\n", formatTimestamp(s.Status.LastSyncTime.String()))
	}
	if s.Status.ErrorMessage != nil {
		errMessage := *s.Status.ErrorMessage
		fmt.Printf("Error Message:  %s\n", errMessage)
	}

	if s.Type == "Opaque" && s.Data != nil && len(*s.Data) > 0 {
		fmt.Println("\n--- Data (Base64 Encoded in K8s) ---")
		for k, v := range *s.Data {
			fmt.Printf("  %s: %s\n", k, v)
		}
	} else if s.Type == "AutoGenerated" && s.GenerationConfig != nil {
		encoding := *s.GenerationConfig.Encoding
		fmt.Println("\n--- Generation Config ---")
		fmt.Printf("  Length:    %d\n", s.GenerationConfig.Length)
		fmt.Printf("  Encoding:  %s\n", encoding)
		fmt.Printf("  Data Keys: %v\n", s.GenerationConfig.DataKeys)
	}

	if s.Labels != nil && len(*s.Labels) > 0 {
		fmt.Println("\n--- Labels ---")
		for k, v := range *s.Labels {
			fmt.Printf("  %s: %s\n", k, v)
		}
	}
}

func formatTimestamp(ts string) string {
	if ts == "" {
		return "N/A"
	}
	if t, err := time.Parse(time.RFC3339, ts); err == nil {
		return t.Format("2006-01-02 15:04:05 MST")
	}
	return ts
}
