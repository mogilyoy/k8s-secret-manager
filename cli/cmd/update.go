/*
Copyright © 2025 NAME HERE <EMAIL ADDRESS>
*/
package cmd

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/mogilyoy/k8s-secret-manager/internal/api"
	"github.com/spf13/cobra"
)

var (
	updateNamespace  string
	updateSecretName string
	updateType       string

	updateDataFile    string
	updateLength      int
	updateEncoding    string
	updateDataKeyVals []string
	updateRegenerate  bool

	updateLabels      []string
	updateAnnotations []string
)

var updateCmd = &cobra.Command{
	Use:   "update NAME",
	Short: "Update a SecretClaim resource properties",
	Long: `Updates properties (labels, annotations, data, or generation config) 
of a specific SecretClaim resource.`,
	Example: `  # Обновить длину генерируемого секрета
  ksec update my-gen-secret -n staging --length 40
  
  # Добавить метку к существующему секрету
  ./ksec update my-secret -n prod --label app=backend`,
	Args: cobra.ExactArgs(1),
	RunE: runUpdateSecret,
}

func init() {
	rootCmd.AddCommand(updateCmd)

	updateCmd.Flags().StringVarP(&updateNamespace, "namespace", "n", "default", "Target Kubernetes namespace")
	updateCmd.Flags().StringVarP(&updateType, "type", "", "", "Change the secret type: Opaque or AutoGenerated")

	updateCmd.Flags().StringVarP(&updateDataFile, "data-file", "f", "", "Path to a JSON file with 'data' payload for Opaque type")

	updateCmd.Flags().IntVarP(&updateLength, "length", "l", 0, "New length of the generated secret")
	updateCmd.Flags().StringVar(&updateEncoding, "encoding", "", "New encoding for the generated secret")
	updateCmd.Flags().StringArrayVar(&updateDataKeyVals, "keys", []string{}, "New comma-separated list of keys to generate")
	updateCmd.Flags().BoolVarP(&updateRegenerate, "regenerate", "r", false, "Force regeneration of the secret value (AutoGenerated only)")

	updateCmd.Flags().StringArrayVar(&updateLabels, "label", []string{}, "Label to set on the resource (e.g., key=value). Can be specified multiple times.")
	updateCmd.Flags().StringArrayVar(&updateAnnotations, "annotation", []string{}, "Annotation to set on the resource (e.g., key=value). Can be specified multiple times.")
	updateCmd.MarkFlagRequired("type")
}

func runUpdateSecret(cmd *cobra.Command, args []string) error {
	updateSecretName = args[0]

	if token == "" {
		return fmt.Errorf("authentication token is missing. Please run 'ksec login' first or provide --token flag")
	}

	req := api.UpdateSecretRequest{}
	fieldsSet := false

	if updateRegenerate {
		if updateType != "AutoGenerated" {
			return fmt.Errorf("--regenerate is only valid for 'AutoGenerated' type secrets")
		}
		fieldsSet = true
		regenerateValue := true
		req.Regenerate = &regenerateValue
	}

	if updateType != "" {
		if updateType != "Opaque" && updateType != "AutoGenerated" {
			return fmt.Errorf("invalid secret type: %s. Must be 'Opaque' or 'AutoGenerated'", updateType)
		}
		reqType := api.UpdateSecretRequestType(updateType)
		req.Type = &reqType
	}

	if len(updateLabels) > 0 {
		fieldsSet = true
		labelsMap := make(map[string]string)
		req.Labels = &labelsMap
		if err := parseKeyValues(updateLabels, labelsMap); err != nil {
			return fmt.Errorf("invalid label format: %w", err)
		}
	}

	if len(updateAnnotations) > 0 {
		fieldsSet = true
		annotationsMap := make(map[string]string)
		req.Annotations = &annotationsMap
		if err := parseKeyValues(updateAnnotations, annotationsMap); err != nil {
			return fmt.Errorf("invalid annotation format: %w", err)
		}
	}

	if updateDataFile != "" {
		fieldsSet = true
		if updateType == "Opaque" || updateType == "" {
			dataMap, err := readDataFromFile(updateDataFile)
			if err != nil {
				return err
			}
			req.Data = &dataMap
		} else { // AutoGenerated
			localConfig, err := readGenerationConfigFromFile(updateDataFile)
			if err != nil {
				return err
			}
			req.GenerationConfig = &api.GenerationConfig{
				Length:   int32(localConfig.Length),
				Encoding: localConfig.Encoding,
				DataKeys: localConfig.DataKeys,
			}
		}
	}

	if updateLength != 0 || updateEncoding != "" || len(updateDataKeyVals) > 0 {
		if updateType != "AutoGenerated" && updateType != "" {
			return fmt.Errorf("generation flags (--length, --encoding, --keys) only valid for AutoGenerated type")
		}
		fieldsSet = true
		encodingToUpdate := api.GenerationConfigEncoding(updateEncoding)
		req.GenerationConfig = &api.GenerationConfig{
			Length:   int32(updateLength),
			Encoding: &encodingToUpdate,
			DataKeys: &updateDataKeyVals,
		}
	}

	if updateType != "" && !fieldsSet {
		if updateType == "AutoGenerated" {
			return fmt.Errorf("AutoGenerated: nothing to update. Provide --length, --keys, --data-file, or --regenerate")
		}
		if updateType == "Opaque" {
			return fmt.Errorf("nothing to update. Provide --data-file or other flags")
		}
	}

	if !fieldsSet {
		return fmt.Errorf("nothing to update. Please provide flags like --length, --label, --data-file, or --annotation")
	}

	reqBody, err := json.Marshal(req)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %w", err)
	}

	updateURL := fmt.Sprintf("%s/secrets/%s?namespace=%s", serverURL, updateSecretName, updateNamespace)

	httpReq, err := http.NewRequest("PUT", updateURL, bytes.NewBuffer(reqBody))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	httpReq.Header.Set("Content-Type", "application/json")
	responseBytes, statusCode, err := doAPIRequest(httpReq)
	if err != nil {
		return err
	}

	if statusCode != http.StatusOK {
		var errResp ErrorResponse
		if json.Unmarshal(responseBytes, &errResp) == nil {
			return fmt.Errorf("API call failed (Status: %d, Code: %s): %s", errResp.StatusCode, errResp.ErrorCode, errResp.ErrorMessage)
		}
		return fmt.Errorf("API call failed with unexpected status: %d %s", statusCode, http.StatusText(statusCode))
	}

	var successResponse api.OkResponse
	if err := json.Unmarshal(responseBytes, &successResponse); err != nil {
		return fmt.Errorf("failed to decode successful response (Status %d): %w", statusCode, err)
	}
	fmt.Printf("✅ SecretClaim '%s/%s' updated successfully.\n", updateNamespace, updateSecretName)

	return nil
}

func parseKeyValues(input []string, output map[string]string) error {
	for _, item := range input {
		parts := [2]string{}
		n, err := fmt.Sscanf(item, "%s=%s", &parts[0], &parts[1])

		if err != nil || n != 2 {
			sepIndex := bytes.IndexByte([]byte(item), '=')
			if sepIndex == -1 {
				return fmt.Errorf("item must be in key=value format: %s", item)
			}
			key := item[:sepIndex]
			value := item[sepIndex+1:]
			output[key] = value
		} else {
			output[parts[0]] = parts[1]
		}
	}
	return nil
}
