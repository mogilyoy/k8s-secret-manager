package handlers

import (
	"context"
	"fmt"
	"io"
	"log/slog"
	"testing"

	secretsv1alpha1 "github.com/mogilyoy/k8s-secret-manager/api/v1alpha1"
	"github.com/mogilyoy/k8s-secret-manager/internal/api"
	"github.com/mogilyoy/k8s-secret-manager/internal/auth"
	"github.com/mogilyoy/k8s-secret-manager/internal/cfg"
	"github.com/mogilyoy/k8s-secret-manager/internal/k8s"
	"github.com/stretchr/testify/require"
	"go.opentelemetry.io/otel"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
)

func newTestSecretHandler(t *testing.T) *SecretHandler {
	t.Helper()

	scheme := runtime.NewScheme()
	require.NoError(t, corev1.AddToScheme(scheme))
	require.NoError(t, secretsv1alpha1.AddToScheme(scheme))

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		Build()

	k8sClient := &k8s.K8sDynamicClient{
		Client: fakeClient,
		Logger: slog.New(slog.NewTextHandler(io.Discard, nil)),
		Tracer: otel.Tracer("test"),
	}

	return &SecretHandler{
		K8sManager: k8sClient,
		Logger:     slog.New(slog.NewTextHandler(io.Discard, nil)),
		Tracer:     otel.Tracer("test"),
	}
}

func TestSecretHandler_CreateSecret_Success(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"default"},
		Role:              "admin",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := newTestSecretHandler(t)

	req := api.CreateSecretRequestObject{
		Body: &api.CreateSecretRequest{
			Name:      "secret1",
			Namespace: "default",
			Type:      api.CreateSecretRequestTypeOpaque,
			Data:      &map[string]string{"foo": "bar"},
		},
	}

	resp, err := handler.CreateSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	ok := *resp.(api.CreateSecret201JSONResponse).Ok
	if !ok {
		t.Errorf("expected Ok: true, got false")
	}

	var claim secretsv1alpha1.SecretClaim
	err = handler.K8sManager.(*k8s.K8sDynamicClient).Client.Get(ctx, types.NamespacedName{Namespace: "default", Name: "secret1"}, &claim)
	if err != nil {
		t.Errorf("failed to get secret claim from fake client: %v", err)
	}
}

func TestSecretHandler_CreateSecret_Forbidden(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"other-ns"},
		Role:              "developer",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := newTestSecretHandler(t)

	req := api.CreateSecretRequestObject{
		Body: &api.CreateSecretRequest{
			Namespace: "default",
			Type:      api.CreateSecretRequestTypeOpaque,
			Data:      &map[string]string{"foo": "bar"},
		},
	}

	resp, err := handler.CreateSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	respErr := resp.(api.CreateSecret403JSONResponse)
	if *respErr.ErrorCode != "Forbidden" {
		t.Errorf("expected Forbidden error, got %s", *respErr.ErrorCode)
	}
}

func TestSecretHandler_CreateSecret_WrongFormat(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"default"},
		Role:              "admin",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := newTestSecretHandler(t)

	data := map[string]string{"foo": "bar"}
	// AutoGenerated с Data, без GenerationConfig — плохой запрос
	req := api.CreateSecretRequestObject{
		Body: &api.CreateSecretRequest{
			Namespace:        "default",
			Type:             api.CreateSecretRequestTypeAutoGenerated,
			Data:             &data,
			GenerationConfig: nil,
		},
	}

	resp, err := handler.CreateSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	respErr := resp.(api.CreateSecret400JSONResponse)
	if *respErr.ErrorCode != "BadRequest" {
		t.Errorf("expected BadRequest error, got %s", *respErr.ErrorCode)
	}
}

type clientWithError struct {
	client.Client
}

func (c *clientWithError) Create(ctx context.Context, obj client.Object, opts ...client.CreateOption) error {
	return fmt.Errorf("forced create error")
}

func (c *clientWithError) List(ctx context.Context, obj client.ObjectList, opts ...client.ListOption) error {
	return fmt.Errorf("forced create error")
}
func (c *clientWithError) Get(ctx context.Context, obk client.ObjectKey, ob client.Object, op ...client.GetOption) error {
	return fmt.Errorf("forced create error")
}

func (c *clientWithError) Update(ctx context.Context, obj client.Object, opt ...client.UpdateOption) error {
	return fmt.Errorf("forced create error")
}

func (c *clientWithError) Delete(ctx context.Context, obj client.Object, opt ...client.DeleteOption) error {
	return fmt.Errorf("forced create error")
}

func getHandlerWithErrorClient(t *testing.T) *SecretHandler {
	scheme := runtime.NewScheme()
	require.NoError(t, corev1.AddToScheme(scheme))
	require.NoError(t, secretsv1alpha1.AddToScheme(scheme))
	fakeClient := fake.NewClientBuilder().WithScheme(scheme).Build()
	errClient := &clientWithError{Client: fakeClient}

	k8sErrClient := &k8s.K8sDynamicClient{
		Client: errClient,
		Logger: slog.New(slog.NewTextHandler(io.Discard, nil)),
		Tracer: otel.Tracer("test"),
	}

	handler := &SecretHandler{
		K8sManager: k8sErrClient,
		Logger:     slog.New(slog.NewTextHandler(io.Discard, nil)),
		Tracer:     otel.Tracer("test"),
	}
	return handler
}

func TestSecretHandler_CreateSecret_K8sError(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"default"},
		Role:              "admin",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := getHandlerWithErrorClient(t)

	req := api.CreateSecretRequestObject{
		Body: &api.CreateSecretRequest{
			Name:      "secret1",
			Namespace: "default",
			Type:      api.CreateSecretRequestTypeOpaque,
			Data:      &map[string]string{"foo": "bar"},
		},
	}

	resp, err := handler.CreateSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	respErr := resp.(api.CreateSecret500JSONResponse)
	if *respErr.ErrorMessage == "" {
		t.Errorf("expected non-empty error message")
	}
}

func TestSecretHandler_ListSecrets_Success(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"default"},
		Role:              "admin",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := newTestSecretHandler(t)

	expected := &secretsv1alpha1.SecretClaim{
		ObjectMeta: metav1.ObjectMeta{Name: "claim1", Namespace: "default"},
	}
	if err := handler.K8sManager.(*k8s.K8sDynamicClient).Client.Create(ctx, expected); err != nil {
		t.Fatalf("failed to create secret claim: %v", err)
	}

	req := api.ListSecretsRequestObject{
		Params: api.ListSecretsParams{
			Namespace: "default",
		},
	}

	resp, err := handler.ListSecrets(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	listResp, ok := resp.(api.ListSecrets200JSONResponse)
	if !ok {
		t.Fatalf("unexpected response type: %T", resp)
	}

	if len(listResp.Items) != 1 || listResp.Items[0].Name != "claim1" {
		t.Errorf("expected 1 item with name claim1, got %v", listResp.Items)
	}
}

func TestSecretHandler_ListSecrets_Forbidden(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"other-ns"},
		Role:              "user",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := newTestSecretHandler(t)

	req := api.ListSecretsRequestObject{
		Params: api.ListSecretsParams{
			Namespace: "default",
		},
	}

	resp, err := handler.ListSecrets(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	respErr := resp.(api.ListSecrets403JSONResponse)
	if *respErr.ErrorCode != "Forbidden" {
		t.Errorf("expected Forbidden error, got %s", *respErr.ErrorCode)
	}
}

func TestSecretHandler_ListSecrets_K8sError(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"default"},
		Role:              "admin",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := getHandlerWithErrorClient(t)

	req := api.ListSecretsRequestObject{
		Params: api.ListSecretsParams{
			Namespace: "default",
		},
	}

	resp, err := handler.ListSecrets(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	respErr := resp.(api.ListSecrets500JSONResponse)
	if *respErr.ErrorMessage == "" {
		t.Errorf("expected error message, got empty")
	}
}

func TestSecretHandler_ListSecrets_ClaimsError(t *testing.T) {
	ctx := context.Background()
	handler := newTestSecretHandler(t)

	req := api.ListSecretsRequestObject{
		Params: api.ListSecretsParams{
			Namespace: "default",
		},
	}

	resp, err := handler.ListSecrets(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	respErr := resp.(api.ListSecrets500JSONResponse)
	if *respErr.ErrorCode != "InternalServerError" {
		t.Errorf("expected InternalServerError, got %s", *respErr.ErrorCode)
	}
}

func TestSecretHandler_GetSecret_SyncedSuccess(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"default"},
		Role:              "admin",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := newTestSecretHandler(t)

	claim := &secretsv1alpha1.SecretClaim{
		ObjectMeta: metav1.ObjectMeta{Name: "mysecret", Namespace: "default"},
		Spec:       secretsv1alpha1.SecretClaimSpec{Type: "Opaque"},
		Status:     secretsv1alpha1.SecretClaimStatus{Synced: true},
	}
	actual := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{Name: "mysecret", Namespace: "default"},
		Data:       map[string][]byte{"key": []byte("value")},
	}
	if err := handler.K8sManager.(*k8s.K8sDynamicClient).Client.Create(ctx, claim); err != nil {
		t.Fatalf("failed create secretclaim: %v", err)
	}
	if err := handler.K8sManager.(*k8s.K8sDynamicClient).Client.Create(ctx, actual); err != nil {
		t.Fatalf("failed create actual secret: %v", err)
	}

	req := api.GetSecretRequestObject{
		Name: "mysecret",
		Params: api.GetSecretParams{
			Namespace: "default",
		},
	}

	resp, err := handler.GetSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	got := resp.(api.GetSecret200JSONResponse)
	if got.Name != "mysecret" {
		t.Errorf("expected name mysecret, got %s", got.Name)
	}
	if len(*got.Data) == 0 {
		t.Error("expected non-empty data")
	}
}

func TestSecretHandler_GetSecret_NotSyncedOpaque(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"default"},
		Role:              "admin",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := newTestSecretHandler(t)

	claim := &secretsv1alpha1.SecretClaim{
		ObjectMeta: metav1.ObjectMeta{Name: "mysecret", Namespace: "default"},
		Spec:       secretsv1alpha1.SecretClaimSpec{Type: "Opaque"},
		Status:     secretsv1alpha1.SecretClaimStatus{Synced: false},
	}
	if err := handler.K8sManager.(*k8s.K8sDynamicClient).Client.Create(ctx, claim); err != nil {
		t.Fatalf("failed create secretclaim: %v", err)
	}

	req := api.GetSecretRequestObject{
		Name: "mysecret",
		Params: api.GetSecretParams{
			Namespace: "default",
		},
	}

	resp, err := handler.GetSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	respErr := resp.(api.GetSecret404JSONResponse)
	if *respErr.ErrorCode != "NotFound" {
		t.Errorf("expected NotFound error, got %s", *respErr.ErrorCode)
	}
}

func TestSecretHandler_GetSecret_Forbidden(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"other-ns"},
		Role:              "user",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := newTestSecretHandler(t)

	req := api.GetSecretRequestObject{
		Name: "anysecret",
		Params: api.GetSecretParams{
			Namespace: "default",
		},
	}

	resp, err := handler.GetSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	respErr := resp.(api.GetSecret403JSONResponse)
	if *respErr.ErrorCode != "Forbidden" {
		t.Errorf("expected Forbidden error, got %s", *respErr.ErrorCode)
	}
}

func TestSecretHandler_GetSecret_ClaimsError(t *testing.T) {
	ctx := context.Background()
	handler := newTestSecretHandler(t)

	req := api.GetSecretRequestObject{
		Name: "anysecret",
		Params: api.GetSecretParams{
			Namespace: "default",
		},
	}

	resp, err := handler.GetSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	respErr := resp.(api.GetSecret500JSONResponse)
	if *respErr.ErrorCode != "InternalServerError" {
		t.Errorf("expected InternalServerError, got %s", *respErr.ErrorCode)
	}
}

func TestSecretHandler_GetSecret_K8sError(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"default"},
		Role:              "admin",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := getHandlerWithErrorClient(t)

	req := api.GetSecretRequestObject{
		Name: "mysecret",
		Params: api.GetSecretParams{
			Namespace: "default",
		},
	}

	resp, err := handler.GetSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	respErr := resp.(api.GetSecret500JSONResponse)
	if *respErr.ErrorMessage == "" {
		t.Errorf("expected non-empty error message")
	}
}

func TestSecretHandler_UpdateSecret_Success(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"default"},
		Role:              "admin",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := newTestSecretHandler(t)

	createBody := api.CreateSecretJSONRequestBody(api.CreateSecretRequest{
		Name:      "secret1",
		Namespace: "default",
		Type:      api.CreateSecretRequestTypeOpaque,
		Data:      &map[string]string{"a": "b"},
		Labels:    &map[string]string{"x": "y"},
	})

	createReq := api.CreateSecretRequestObject{
		Params: api.CreateSecretParams{},
		Body:   &createBody,
	}

	handler.CreateSecret(ctx, createReq)

	secretType := api.UpdateSecretRequestTypeOpaque
	req := api.UpdateSecretRequestObject{
		Name: "secret1",
		Params: api.UpdateSecretParams{
			Namespace: "default",
		},
		Body: &api.UpdateSecretRequest{
			Type:   &secretType,
			Data:   &map[string]string{"a": "b"},
			Labels: &map[string]string{"x": "y"},
		},
	}

	resp, err := handler.UpdateSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	updateResp := resp.(api.UpdateSecret200JSONResponse)
	ok := updateResp.Ok
	if !*ok {
		t.Errorf("expected Ok: true, got false")
	}
}

func TestSecretHandler_UpdateSecret_WrongFormat(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"default"},
		Role:              "admin",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := newTestSecretHandler(t)

	secretType := api.UpdateSecretRequestTypeAutoGenerated
	data := map[string]string{"foo": "bar"} // не должен предоставляться для AutoGenerated
	req := api.UpdateSecretRequestObject{
		Name: "secret1",
		Params: api.UpdateSecretParams{
			Namespace: "default",
		},
		Body: &api.UpdateSecretRequest{
			Type: &secretType,
			Data: &data,
		},
	}

	resp, err := handler.UpdateSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	respErr := resp.(api.UpdateSecret400JSONResponse)
	if *respErr.ErrorCode != "BadRequest" {
		t.Errorf("expected BadRequest, got %s", *respErr.ErrorCode)
	}
}

func TestSecretHandler_UpdateSecret_Forbidden(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"other-ns"},
		Role:              "developer",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := newTestSecretHandler(t)

	secretType := api.UpdateSecretRequestTypeOpaque
	req := api.UpdateSecretRequestObject{
		Name: "secret1",
		Params: api.UpdateSecretParams{
			Namespace: "default",
		},
		Body: &api.UpdateSecretRequest{
			Type: &secretType,
			Data: &map[string]string{"a": "b"},
		},
	}

	resp, err := handler.UpdateSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	respErr := resp.(api.UpdateSecret403JSONResponse)
	if *respErr.ErrorCode != "Forbidden" {
		t.Errorf("expected Forbidden, got %s", *respErr.ErrorCode)
	}
}

func TestSecretHandler_UpdateSecret_ClaimsError(t *testing.T) {
	ctx := context.Background()
	handler := newTestSecretHandler(t)

	secretType := api.UpdateSecretRequestTypeOpaque
	req := api.UpdateSecretRequestObject{
		Name: "secret1",
		Params: api.UpdateSecretParams{
			Namespace: "default",
		},
		Body: &api.UpdateSecretRequest{
			Type: &secretType,
			Data: &map[string]string{"a": "b"},
		},
	}

	// Без claims в контексте - проверка ошибки
	resp, err := handler.UpdateSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	respErr := resp.(api.UpdateSecret500JSONResponse)
	if *respErr.ErrorCode != "InternalServerError" {
		t.Errorf("expected InternalServerError, got %s", *respErr.ErrorCode)
	}
}

func TestSecretHandler_UpdateSecret_K8sError(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"default"},
		Role:              "admin",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := getHandlerWithErrorClient(t) // твой handler с клиентом, возвращающим ошибку

	secretType := api.UpdateSecretRequestTypeOpaque
	req := api.UpdateSecretRequestObject{
		Name: "secret1",
		Params: api.UpdateSecretParams{
			Namespace: "default",
		},
		Body: &api.UpdateSecretRequest{
			Type: &secretType,
			Data: &map[string]string{"a": "b"},
		},
	}

	resp, err := handler.UpdateSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	respErr := resp.(api.UpdateSecret500JSONResponse)
	if *respErr.ErrorMessage == "" {
		t.Errorf("expected non-empty error message")
	}
}

func TestSecretHandler_DeleteSecret_Success(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"default"},
		Role:              "admin",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := newTestSecretHandler(t)

	// Создаём SecretClaim для удаления
	claim := &secretsv1alpha1.SecretClaim{
		ObjectMeta: metav1.ObjectMeta{Name: "secret1", Namespace: "default"},
		Spec:       secretsv1alpha1.SecretClaimSpec{Type: "Opaque"},
	}
	if err := handler.K8sManager.(*k8s.K8sDynamicClient).Client.Create(ctx, claim); err != nil {
		t.Fatalf("setup: failed to create SecretClaim: %v", err)
	}

	req := api.DeleteSecretRequestObject{
		Name: "secret1",
		Params: api.DeleteSecretParams{
			Namespace: "default",
		},
	}

	resp, err := handler.DeleteSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	delResp := resp.(api.DeleteSecret200JSONResponse)
	ok := delResp.Ok
	if !*ok {
		t.Errorf("expected Ok: true, got false")
	}

	var got secretsv1alpha1.SecretClaim
	err = handler.K8sManager.(*k8s.K8sDynamicClient).Client.Get(ctx, types.NamespacedName{Name: "secret1", Namespace: "default"}, &got)
	if err == nil {
		t.Error("expected secret claim to be deleted, but it still exists")
	}
}

func TestSecretHandler_DeleteSecret_Forbidden(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"other-ns"},
		Role:              "developer",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := newTestSecretHandler(t)

	req := api.DeleteSecretRequestObject{
		Name: "secret1",
		Params: api.DeleteSecretParams{
			Namespace: "default",
		},
	}

	resp, err := handler.DeleteSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	respErr := resp.(api.DeleteSecret403JSONResponse)
	if *respErr.ErrorCode != "Forbidden" {
		t.Errorf("expected Forbidden, got %s", *respErr.ErrorCode)
	}
}

func TestSecretHandler_DeleteSecret_ClaimsError(t *testing.T) {
	ctx := context.Background()
	handler := newTestSecretHandler(t)

	req := api.DeleteSecretRequestObject{
		Name: "secret1",
		Params: api.DeleteSecretParams{
			Namespace: "default",
		},
	}

	resp, err := handler.DeleteSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	respErr := resp.(api.DeleteSecret500JSONResponse)
	if *respErr.ErrorCode != "InternalServerError" {
		t.Errorf("expected InternalServerError, got %s", *respErr.ErrorCode)
	}
}

func TestSecretHandler_DeleteSecret_K8sError(t *testing.T) {
	ctx := context.Background()
	claims := &auth.Claims{
		AllowedNamespaces: []string{"default"},
		Role:              "admin",
	}
	ctx = auth.ContextWithClaims(ctx, claims)

	handler := getHandlerWithErrorClient(t)

	req := api.DeleteSecretRequestObject{
		Name: "secret1",
		Params: api.DeleteSecretParams{
			Namespace: "default",
		},
	}

	resp, err := handler.DeleteSecret(ctx, req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	respErr := resp.(api.DeleteSecret500JSONResponse)
	if *respErr.ErrorMessage == "" {
		t.Errorf("expected non-empty error message")
	}
}

func TestSecretHandler_AuthUser_Success(t *testing.T) {
	password := "secret"

	hash, err := auth.HashPassword(password)
	if err != nil {
		t.Fatalf("failed to hash password: %v", err)
	}

	user := cfg.User{
		Username:     "testuser",
		PasswordHash: hash,
	}

	cfgMock := cfg.Config{
		Users: []cfg.User{user},
		JWT:   cfg.JWTConfig{Secret: "mysecretjwtkey"},
	}

	handler := &SecretHandler{
		cfg:    cfgMock,
		Logger: slog.New(slog.NewTextHandler(io.Discard, nil)),
		Tracer: otel.Tracer("test"),
	}

	req := api.AuthUserRequestObject{
		Body: &api.AuthUserRequest{
			Username: "testuser",
			Password: password,
		},
	}

	resp, err := handler.AuthUser(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	authResp, ok := resp.(api.AuthUser200JSONResponse)
	if !ok {
		t.Fatalf("unexpected response type: %T", resp)
	}
	if authResp.Token == "" || authResp.ExpiresIn == nil {
		t.Errorf("expected valid token and expiresIn")
	}
}

func TestSecretHandler_AuthUser_WrongCredentials(t *testing.T) {
	user := cfg.User{
		Username:     "testuser",
		PasswordHash: "$2a$10$invalidhashforpassword",
	}

	cfgMock := cfg.Config{
		Users: []cfg.User{user},
		JWT:   cfg.JWTConfig{Secret: "mysecretjwtkey"},
	}

	handler := &SecretHandler{
		cfg:    cfgMock,
		Logger: slog.New(slog.NewTextHandler(io.Discard, nil)),
		Tracer: otel.Tracer("test"),
	}

	req := api.AuthUserRequestObject{
		Body: &api.AuthUserRequest{
			Username: "testuser",
			Password: "wrongpassword",
		},
	}

	resp, err := handler.AuthUser(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	respErr, ok := resp.(api.AuthUser401JSONResponse)
	if !ok {
		t.Fatalf("unexpected response type: %T", resp)
	}

	if *respErr.ErrorCode != "Unauthorized" {
		t.Errorf("expected Unauthorized error code, got %s", *respErr.ErrorCode)
	}
}

func TestSecretHandler_AuthUser_JWTError(t *testing.T) {
	password := "secret"

	hash, err := auth.HashPassword(password)
	if err != nil {
		t.Fatalf("failed to hash password: %v", err)
	}

	user := cfg.User{
		Username:     "testuser",
		PasswordHash: hash,
	}

	cfgMock := cfg.Config{
		Users: []cfg.User{user},
		JWT:   cfg.JWTConfig{Secret: ""},
	}

	handler := &SecretHandler{
		cfg:    cfgMock,
		Logger: slog.New(slog.NewTextHandler(io.Discard, nil)),
		Tracer: otel.Tracer("test"),
	}

	req := api.AuthUserRequestObject{
		Body: &api.AuthUserRequest{
			Username: "testuser",
			Password: password,
		},
	}

	resp, err := handler.AuthUser(context.Background(), req)
	if err == nil {
		t.Fatalf("expected error when generating JWT, got nil")
	}

	respErr, ok := resp.(api.AuthUser500JSONResponse)
	if !ok {
		t.Fatalf("unexpected response type: %T", resp)
	}

	if *respErr.ErrorCode != "Internal Server Error" {
		t.Errorf("expected Internal Server Error error code, got %s", *respErr.ErrorCode)
	}
}
