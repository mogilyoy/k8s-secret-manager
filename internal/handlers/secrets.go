package handlers

import (
	"context"
	"log/slog"

	"github.com/mogilyoy/k8s-secret-manager/internal/api"
	"github.com/mogilyoy/k8s-secret-manager/internal/auth"
	"github.com/mogilyoy/k8s-secret-manager/internal/observability"
	"go.opentelemetry.io/otel/codes"
	corev1 "k8s.io/api/core/v1"
)

func (h *SecretHandler) CreateSecret(ctx context.Context, request api.CreateSecretRequestObject) (api.CreateSecretResponseObject, error) {
	ctx, span := h.Tracer.Start(ctx, "SecretHandler.CreateSecret")
	defer span.End()
	logger := observability.LoggerFromContext(ctx)

	claims, err := auth.GetClaimsFromContext(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Cannot parse request context")
		logger.Error("Failed to parse request context/claims", slog.Any("error", err))
		return BuildCreateSecretErrorResponse(ErrorResult{
			ErrorMessage: "Cannot parse request context",
			ErrorCode:    "InternalServerError",
			StatusCode:   500,
		}), nil
	}

	if !auth.IsNamespaceAllowed(request.Body.Namespace, claims.AllowedNamespaces) || claims.Role == "developer" {
		span.SetStatus(codes.Error, "Access denied")
		logger.Warn("Access denied for namespace",
			slog.String("namespace", request.Body.Namespace),
			slog.String("role", claims.Role))

		return BuildCreateSecretErrorResponse(ErrorResult{
			ErrorMessage: "Access denied: insufficient role or namespace permissions",
			ErrorCode:    "Forbidden",
			StatusCode:   403,
		}), nil
	}

	isValidType := request.Body.Type == api.CreateSecretRequestTypeOpaque || request.Body.Type == api.CreateSecretRequestTypeAutoGenerated
	isAutoGenerated := request.Body.Type == api.CreateSecretRequestTypeAutoGenerated
	configProvided := request.Body.GenerationConfig != nil

	if isAutoGenerated && !configProvided || (!isAutoGenerated && configProvided) || !isValidType {
		span.SetStatus(codes.Error, "Wrong request format")
		logger.Warn("Wrong request format", slog.Any("request_type", string(request.Body.Type)), slog.Any("data_provided", request.Body.Data), slog.Any("config_provided", configProvided))
		return BuildCreateSecretErrorResponse(ErrorResult{
			ErrorMessage: "Wrong request format",
			ErrorCode:    "BadRequest",
			StatusCode:   400,
		}), nil
	}

	err = h.K8sManager.CreateSecretClaim(ctx, request.Body.Name, request.Body.Namespace, string(request.Body.Type), request.Body.Data, request.Body.GenerationConfig, request.Body.Labels, request.Body.Annotations)
	if err != nil {
		return BuildCreateSecretErrorResponse(HandleK8sError(ctx, err)), nil
	}

	logger.Info("Successfully created secret claim", slog.String("namespace", request.Body.Namespace), slog.String("name", request.Body.Name))
	span.SetStatus(codes.Ok, "Success")
	return api.CreateSecret201JSONResponse{
		OkResponseJSONResponse: api.OkResponseJSONResponse{
			Ok: BoolPnc(true),
		},
	}, nil
}

func (h *SecretHandler) ListSecrets(ctx context.Context, request api.ListSecretsRequestObject) (api.ListSecretsResponseObject, error) {
	ctx, span := h.Tracer.Start(ctx, "SecretHandler.ListSecrets")
	defer span.End()

	logger := observability.LoggerFromContext(ctx)

	claims, err := auth.GetClaimsFromContext(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Cannot parse request context")
		logger.Error("Failed to parse request context/claims", slog.Any("error", err))
		return BuildListSecretsErrorResponse(ErrorResult{
			ErrorMessage: "Cannot parse request context",
			ErrorCode:    "InternalServerError",
			StatusCode:   500,
		}), nil
	}
	if !auth.IsNamespaceAllowed(request.Params.Namespace, claims.AllowedNamespaces) {
		span.SetStatus(codes.Error, "Access denied")
		logger.Warn("Access denied for namespace",
			slog.String("namespace", request.Params.Namespace))

		return BuildListSecretsErrorResponse(ErrorResult{
			ErrorMessage: "Access denied: insufficient role or namespace permissions",
			ErrorCode:    "Forbidden",
			StatusCode:   403,
		}), nil
	}

	secretClaimList, err := h.K8sManager.ListSecretClaim(ctx, request.Params.Namespace)
	if err != nil {
		return BuildListSecretsErrorResponse(HandleK8sError(ctx, err)), nil
	}

	secretSummaryItems := mapSecretListToResponseList(secretClaimList.Items)

	logger.Info("Successfully fetched secret claims list", slog.String("namespace", request.Params.Namespace), slog.Int("count", len(secretClaimList.Items)))
	span.SetStatus(codes.Ok, "Success")
	return api.ListSecrets200JSONResponse{
		Items: secretSummaryItems,
	}, nil
}

func (h *SecretHandler) GetSecret(ctx context.Context, request api.GetSecretRequestObject) (api.GetSecretResponseObject, error) {
	ctx, span := h.Tracer.Start(ctx, "SecretHandler.GetSecret")
	defer span.End()
	logger := observability.LoggerFromContext(ctx)

	claims, err := auth.GetClaimsFromContext(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Cannot parse request context")
		logger.Error("Failed to parse request context/claims", slog.Any("error", err))
		return BuildGetSecretErrorResponse(ErrorResult{
			ErrorMessage: "Cannot parse request context",
			ErrorCode:    "InternalServerError",
			StatusCode:   500,
		}), nil
	}

	if !auth.IsNamespaceAllowed(request.Params.Namespace, claims.AllowedNamespaces) {
		span.SetStatus(codes.Error, "Access denied")
		logger.Warn("Access denied for namespace",
			slog.String("namespace", request.Params.Namespace))

		return BuildGetSecretErrorResponse(ErrorResult{
			ErrorMessage: "Access denied: insufficient role or namespace permissions",
			ErrorCode:    "Forbidden",
			StatusCode:   403,
		}), nil
	}

	secret, err := h.K8sManager.GetSecretClaim(ctx, request.Name, request.Params.Namespace)

	if err != nil {
		return BuildGetSecretErrorResponse(HandleK8sError(ctx, err)), nil
	}

	var actualData *corev1.Secret = nil
	if secret.Status.Synced {

		actualData, err = h.K8sManager.GetActualSecret(ctx, request.Name, request.Params.Namespace)
		if err != nil {
			return BuildGetSecretErrorResponse(HandleK8sError(ctx, err)), nil
		}
	}

	if actualData == nil && secret.Spec.Type == "Opaque" {
		logger.Warn("SecretClaim is not synced yet; no actual secret data available", slog.String("namespace", request.Params.Namespace), slog.String("name", request.Name))
		return BuildGetSecretErrorResponse(ErrorResult{
			ErrorMessage: "SecretClaim is not synced yet; no actual secret data available",
			ErrorCode:    "NotFound",
			StatusCode:   404,
		}), nil
	}

	secretResponse := mapClaimToSecretResponse(secret, actualData)

	logger.Info("Successfully fetched secret claim", slog.String("namespace", request.Params.Namespace), slog.String("name", request.Name))
	span.SetStatus(codes.Ok, "Success")
	return api.GetSecret200JSONResponse(secretResponse), nil
}

func (h *SecretHandler) UpdateSecret(ctx context.Context, request api.UpdateSecretRequestObject) (api.UpdateSecretResponseObject, error) {
	ctx, span := h.Tracer.Start(ctx, "SecretHandler.UpdateSecret")
	defer span.End()
	logger := observability.LoggerFromContext(ctx)

	claims, err := auth.GetClaimsFromContext(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Cannot parse request context")
		logger.Error("Failed to parse request context/claims", slog.Any("error", err))
		return BuildUpdateSecretErrorResponse(ErrorResult{
			ErrorMessage: "Cannot parse request context",
			ErrorCode:    "InternalServerError",
			StatusCode:   500,
		}), nil
	}

	if !auth.IsNamespaceAllowed(request.Params.Namespace, claims.AllowedNamespaces) || claims.Role == "developer" {
		span.SetStatus(codes.Error, "Access denied")
		logger.Warn("Access denied for namespace",
			slog.String("namespace", request.Params.Namespace),
			slog.String("role", claims.Role))
		return BuildUpdateSecretErrorResponse(ErrorResult{
			ErrorMessage: "Access denied: insufficient role or namespace permissions",
			ErrorCode:    "Forbidden",
			StatusCode:   403,
		}), nil
	}

	dataProvided := request.Body.Data != nil && len(*request.Body.Data) > 0
	configProvided := request.Body.GenerationConfig != nil
	typeProvided := request.Body.Type != nil
	newType := ""
	if typeProvided {
		newType = string(*request.Body.Type)
	}

	if typeProvided {
		isAutoGenerated := newType == string(api.UpdateSecretRequestTypeAutoGenerated)
		if (isAutoGenerated && dataProvided) || (!isAutoGenerated && configProvided) {
			return BuildUpdateSecretErrorResponse(ErrorResult{
				ErrorMessage: "Wrong request format: AutoGenerated requires GenerationConfig, Opaque requires Data",
				ErrorCode:    "BadRequest",
				StatusCode:   400,
			}), nil
		}
	}

	regenerate := false
	if request.Body.Regenerate != nil {
		regenerate = *request.Body.Regenerate
	}

	err = h.K8sManager.UpdateSecretClaim(ctx, request.Name, request.Params.Namespace,
		newType, regenerate, request.Body.Data, request.Body.GenerationConfig,
		request.Body.Labels, request.Body.Annotations)
	if err != nil {
		return BuildUpdateSecretErrorResponse(HandleK8sError(ctx, err)), nil
	}

	logger.Info("Successfully updated secret claim", slog.String("namespace", request.Params.Namespace), slog.String("name", request.Name))
	span.SetStatus(codes.Ok, "Success")
	return api.UpdateSecret200JSONResponse{
		OkResponseJSONResponse: api.OkResponseJSONResponse{
			Ok: BoolPnc(true),
		},
	}, nil
}

func (h *SecretHandler) DeleteSecret(ctx context.Context, request api.DeleteSecretRequestObject) (api.DeleteSecretResponseObject, error) {
	ctx, span := h.Tracer.Start(ctx, "SecretHandler.DeleteSecret")
	defer span.End()
	logger := observability.LoggerFromContext(ctx)

	claims, err := auth.GetClaimsFromContext(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Cannot parse request context")
		logger.Error("Failed to parse request context/claims", slog.Any("error", err))

		return BuildDeleteSecretErrorResponse(ErrorResult{
			ErrorMessage: "Cannot parse request context",
			ErrorCode:    "InternalServerError",
			StatusCode:   500,
		}), nil
	}

	if !auth.IsNamespaceAllowed(request.Params.Namespace, claims.AllowedNamespaces) || claims.Role == "developer" {
		span.SetStatus(codes.Error, "Access denied")
		logger.Warn("Access denied for namespace",
			slog.String("namespace", request.Params.Namespace),
			slog.String("role", claims.Role))

		return BuildDeleteSecretErrorResponse(ErrorResult{
			ErrorMessage: "Access denied: insufficient role or namespace permissions",
			ErrorCode:    "Forbidden",
			StatusCode:   403,
		}), nil
	}

	err = h.K8sManager.DeleteSecretClaim(ctx, request.Name, request.Params.Namespace)
	if err != nil {
		return BuildDeleteSecretErrorResponse(HandleK8sError(ctx, err)), nil
	}

	logger.Info("Successfully deleted secret claim", slog.String("namespace", request.Params.Namespace), slog.String("name", request.Name))
	span.SetStatus(codes.Ok, "Success")
	return api.DeleteSecret200JSONResponse{
		OkResponseJSONResponse: api.OkResponseJSONResponse{
			Ok: BoolPnc(true),
		},
	}, nil

}
