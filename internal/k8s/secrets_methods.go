package k8s

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	secretsv1alpha1 "github.com/mogilyoy/k8s-secret-manager/api/v1alpha1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

func (m *K8sDynamicClient) CreateSecretClaim(ctx context.Context, name, namespace, claimType string, data map[string]string) error {
	claim := &secretsv1alpha1.SecretClaim{
		ObjectMeta: metav1.ObjectMeta{
			Name:      name,
			Namespace: namespace,
		},
		Spec: secretsv1alpha1.SecretClaimSpec{
			Type: claimType,
			Data: data,
		},
	}

	if err := m.Client.Create(ctx, claim); err != nil {
		return err
	}

	return nil
}

func (m *K8sDynamicClient) UpdateSecretClaim(ctx context.Context, name, namespace, claimType string, regenerate bool, data map[string]string) (*secretsv1alpha1.SecretClaim, error) {
	existingClaim, err := m.GetSecretClaim(ctx, name, namespace)
	if err != nil {
		return nil, fmt.Errorf("failed to read SecretClaim %s before update: %w", name, err)
	}

	if claimType != "" {
		existingClaim.Spec.Type = claimType
	}
	if data != nil {
		existingClaim.Spec.Data = data
	}

	switch existingClaim.Spec.Type {
	case "AutoGenerated":
		if existingClaim.Spec.Generation == nil {
			existingClaim.Spec.Generation = &secretsv1alpha1.GenerationConfig{
				Length:   16,
				Encoding: "alphanumeric",
			}
		}
		if regenerate {
			existingClaim.Spec.Generation.ReconcileTrigger = uuid.NewString()
			existingClaim.Spec.Data = nil
		}
	case "Opaque":
		existingClaim.Spec.Generation = nil
	}

	err = m.Client.Update(
		ctx,
		existingClaim,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update SecretClaim %s in namespace %s: %w", name, namespace, err)
	}
	return existingClaim, nil
}

func (m *K8sDynamicClient) DeleteSecretClaim(ctx context.Context, name, namespace string) error {
	claim := &secretsv1alpha1.SecretClaim{
		ObjectMeta: metav1.ObjectMeta{
			Name:      name,
			Namespace: namespace,
		},
		Spec: secretsv1alpha1.SecretClaimSpec{},
	}

	err := m.Client.Delete(
		ctx,
		claim,
	)
	if err != nil {
		if client.IgnoreNotFound(err) != nil { // Не считаем серьезной ошибкой delete
			return fmt.Errorf("failed to delete SecretClaim %s in namespace %s: %w", name, namespace, err)
		}
	}
	return nil
}

func (m *K8sDynamicClient) GetSecretClaim(ctx context.Context, name, namespace string) (*secretsv1alpha1.SecretClaim, error) {
	secret := &secretsv1alpha1.SecretClaim{}
	err := m.Client.Get(
		ctx,
		client.ObjectKey{Namespace: namespace, Name: name},
		secret,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get SecretClaim %s in namespace %s: %w", name, namespace, err)
	}
	return secret, nil
}

func (m *K8sDynamicClient) GetActualSecretData(ctx context.Context, name, namespace string) (map[string]string, error) {

	actualSecret := &corev1.Secret{}

	err := m.Client.Get(
		ctx,
		client.ObjectKey{Namespace: namespace, Name: name},
		actualSecret,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get native Secret %s: %w", name, err)
	}

	result := make(map[string]string, len(actualSecret.Data))
	for k, v := range actualSecret.Data {
		result[k] = string(v)
	}

	return result, nil
}

func (m *K8sDynamicClient) ListSecretClaim(ctx context.Context, namespace string) (*secretsv1alpha1.SecretClaimList, error) {

	secretClaimList := &secretsv1alpha1.SecretClaimList{}
	err := m.Client.List(
		ctx,
		secretClaimList,
		client.InNamespace(namespace),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to list SecretClaims in namespace %s: %w", namespace, err)
	}
	return secretClaimList, nil
}
