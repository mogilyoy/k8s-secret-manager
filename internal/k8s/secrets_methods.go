package k8s

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"strings"

	"github.com/google/uuid"
	secretsv1alpha1 "github.com/mogilyoy/k8s-secret-manager/api/v1alpha1"
	"github.com/mogilyoy/k8s-secret-manager/internal/api"
	"github.com/mogilyoy/k8s-secret-manager/internal/observability"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

func (m *K8sDynamicClient) CreateSecretClaim(ctx context.Context, name, namespace, claimType string, data *map[string]string, generationConfig *api.GenerationConfig, labels *map[string]string, annotations *map[string]string) error {

	ctx, span := m.Tracer.Start(ctx, "K8sDynamicClient.CreateSecretClaim")
	defer span.End()
	m.Logger.Debug("K8s: attempting to update SecretClaims",
		slog.String("namespace", namespace),
		slog.String("name", name),
		slog.String("type", claimType))
	span.SetAttributes(semconv.K8SNamespaceName(namespace))

	spec := secretsv1alpha1.SecretClaimSpec{
		Type: claimType,
	}

	if data != nil {
		spec.Data = *data
	}

	switch claimType {
	case "AutoGenerated":
		if int(generationConfig.Length) < 8 || (generationConfig.DataKeys == nil || len(*generationConfig.DataKeys) == 0) || generationConfig.Encoding == nil {
			span.RecordError(errors.New("invalid generationConfig"))
			span.SetStatus(codes.Error, "Invalid generationConfig")
			m.Logger.Error("K8s: invalid generationConfig", slog.String("namespace", namespace), slog.String("name", name), slog.Int("length", int(generationConfig.Length)))
			return fmt.Errorf("invalid generationConfig")
		}

		var dataKeys []string
		if len(*generationConfig.DataKeys) == 1 {
			jsonKeys := (*generationConfig.DataKeys)[0]
			if err := json.Unmarshal([]byte(jsonKeys), &dataKeys); err == nil {
				m.Logger.Debug("Parsed JSON DataKeys", slog.Any("keys", dataKeys))
			} else {
				dataKeys = strings.Split(jsonKeys, ",")
				for i, key := range dataKeys {
					dataKeys[i] = strings.TrimSpace(key)
				}
			}
		} else {
			dataKeys = *generationConfig.DataKeys
		}

		spec.Generation = &secretsv1alpha1.GenerationConfig{
			Length:           int(generationConfig.Length),
			Encoding:         string(*generationConfig.Encoding),
			DataKeys:         dataKeys,
			ReconcileTrigger: uuid.NewString(),
		}

		spec.Data = nil

	case "Opaque":
		spec.Generation = nil
	}

	labelsToSet := map[string]string{}
	if labels != nil {
		labelsToSet = *labels
	}

	annotationsToSet := map[string]string{}
	if annotations != nil {
		annotationsToSet = *annotations
	}

	traceparent := observability.GetTraceParentHeader(ctx)
	if traceparent != "" {
		annotationsToSet[observability.K8sTraceparentAnnotationKey] = traceparent
		span.SetAttributes(attribute.String("traceparent.propagation", traceparent))
		m.Logger.Debug("Propagating traceparent to SecretClaim annotations", slog.String("traceparent", traceparent))
	}

	claim := &secretsv1alpha1.SecretClaim{
		ObjectMeta: metav1.ObjectMeta{
			Name:        name,
			Namespace:   namespace,
			Labels:      labelsToSet,
			Annotations: annotationsToSet,
		},
		Spec: spec,
	}
	if err := m.Client.Create(ctx, claim); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Failed to create SecretClaim")
		m.Logger.Error("K8s: failed to create SecretClaim", slog.String("namespace", namespace), slog.String("name", name), slog.String("error", err.Error()))
		return fmt.Errorf("failed to create SecretClaim %s in namespace %s: %w", name, namespace, err)
	}
	span.SetStatus(codes.Ok, "Success")
	return nil
}

func (m *K8sDynamicClient) UpdateSecretClaim(ctx context.Context, name, namespace, claimType string, regenerate bool, data *map[string]string, generationConfig *api.GenerationConfig, labels *map[string]string, annotations *map[string]string) error {
	ctx, span := m.Tracer.Start(ctx, "K8sDynamicClient.UpdateSecretClaim")
	defer span.End()
	m.Logger.Debug("K8s: attempting to update SecretClaims",
		slog.String("namespace", namespace),
		slog.String("name", name),
		slog.String("type", claimType),
		slog.Bool("regenerate", regenerate))
	span.SetAttributes(semconv.K8SNamespaceName(namespace))

	existingClaim, err := m.GetSecretClaim(ctx, name, namespace)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Failed to read SecretClaims before update")
		m.Logger.Error("K8s: failed to read SecretClaims before update", slog.String("namespace", namespace), slog.String("name", name), slog.String("error", err.Error()))
		return fmt.Errorf("failed to read SecretClaim %s before update: %w", name, err)
	}

	if claimType != "" {
		existingClaim.Spec.Type = claimType
	}
	if data != nil {
		existingClaim.Spec.Data = *data
	}
	if labels != nil {
		existingClaim.ObjectMeta.Labels = *labels
	}
	if annotations != nil {
		existingClaim.ObjectMeta.Annotations = *annotations
	}
	traceparent := observability.GetTraceParentHeader(ctx)
	if traceparent != "" {
		existingClaim.Annotations[observability.K8sTraceparentAnnotationKey] = traceparent
		span.SetAttributes(attribute.String("traceparent.propagation", traceparent))
		m.Logger.Debug("Propagating traceparent to SecretClaim annotations", slog.String("traceparent", traceparent))
	}

	switch existingClaim.Spec.Type {
	case "AutoGenerated":
		if generationConfig != nil {
			if int(generationConfig.Length) < 8 || (generationConfig.DataKeys == nil || len(*generationConfig.DataKeys) == 0) || generationConfig.Encoding == nil {
				span.RecordError(errors.New("invalid generationConfig"))
				span.SetStatus(codes.Error, "Invalid generationConfig")
				m.Logger.Error("K8s: invalid generationConfig", slog.String("namespace", namespace), slog.String("name", name), slog.Int("length", int(generationConfig.Length)))
				return fmt.Errorf("invalid generationConfig")
			}

			var dataKeys []string
			if len(*generationConfig.DataKeys) == 1 {
				jsonKeys := (*generationConfig.DataKeys)[0]
				if err := json.Unmarshal([]byte(jsonKeys), &dataKeys); err == nil {
					m.Logger.Debug("Parsed JSON DataKeys", slog.Any("keys", dataKeys))
				} else {
					dataKeys = strings.Split(jsonKeys, ",")
					for i, key := range dataKeys {
						dataKeys[i] = strings.TrimSpace(key)
					}
				}
			} else {
				dataKeys = *generationConfig.DataKeys
			}

			existingClaim.Spec.Generation = &secretsv1alpha1.GenerationConfig{
				Length:   int(generationConfig.Length),
				Encoding: string(*generationConfig.Encoding),
				DataKeys: dataKeys,
			}
		}

		if existingClaim.Spec.Generation == nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, "generationConfig must be provided")
			m.Logger.Error("K8s: generationConfig must be provided when switching to AutoGenerated secret type if no existing configuration is present", slog.String("namespace", namespace), slog.String("name", name))
			return fmt.Errorf("generationConfig must be provided when switching to AutoGenerated secret type if no existing configuration is present")
		}

		if regenerate {
			existingClaim.Spec.Generation.ReconcileTrigger = uuid.NewString()
		}
		existingClaim.Spec.Data = nil

	case "Opaque":
		existingClaim.Spec.Generation = nil
	}

	m.Logger.Debug("K8s: updating SecretClaims",
		slog.String("namespace", namespace),
		slog.String("name", name))
	err = m.Client.Update(
		ctx,
		existingClaim,
	)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Failed to update SecretClaim")
		m.Logger.Error("K8s: failed to update SecretClaim", slog.String("namespace", namespace), slog.String("name", name), slog.String("error", err.Error()))
		return fmt.Errorf("failed to update SecretClaim %s in namespace %s: %w", name, namespace, err)
	}
	span.SetStatus(codes.Ok, "Success")
	return nil
}

func (m *K8sDynamicClient) DeleteSecretClaim(ctx context.Context, name, namespace string) error {
	ctx, span := m.Tracer.Start(ctx, "K8sDynamicClient.DeleteSecretClaim")
	defer span.End()
	m.Logger.Debug("K8s: attempting to delete SecretClaims",
		slog.String("namespace", namespace),
		slog.String("name", name))
	span.SetAttributes(semconv.K8SNamespaceName(namespace))

	claim := &secretsv1alpha1.SecretClaim{
		ObjectMeta: metav1.ObjectMeta{
			Name:      name,
			Namespace: namespace,
		},
		Spec: secretsv1alpha1.SecretClaimSpec{},
	}

	m.Logger.Debug("K8s: deleting SecretClaims",
		slog.String("namespace", namespace),
		slog.String("name", name))
	err := m.Client.Delete(
		ctx,
		claim,
	)
	if err != nil {
		if client.IgnoreNotFound(err) != nil { // Не считаем серьезной ошибкой 404
			span.RecordError(err)
			span.SetStatus(codes.Error, "Failed to delete SecretClaims")
			m.Logger.Error("K8s: failed to delete SecretClaims", slog.String("namespace", namespace), slog.String("name", name), slog.String("error", err.Error()))
			return fmt.Errorf("failed to delete SecretClaim %s in namespace %s: %w", name, namespace, err)
		}
		m.Logger.Info("K8s: failed to delete SecretClaims", slog.String("namespace", namespace), slog.String("error", err.Error()))
	}
	span.SetStatus(codes.Ok, "Success")
	return nil
}

func (m *K8sDynamicClient) GetSecretClaim(ctx context.Context, name, namespace string) (*secretsv1alpha1.SecretClaim, error) {
	ctx, span := m.Tracer.Start(ctx, "K8sDynamicClient.GetSecretClaim")
	defer span.End()

	m.Logger.Debug("K8s: attempting to get SecretClaims",
		slog.String("namespace", namespace),
		slog.String("name", name))
	span.SetAttributes(semconv.K8SNamespaceName(namespace))

	secret := &secretsv1alpha1.SecretClaim{}
	err := m.Client.Get(
		ctx,
		client.ObjectKey{Namespace: namespace, Name: name},
		secret,
	)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Failed to get SecretClaims")
		m.Logger.Error("K8s: failed to get SecretClaims", slog.String("namespace", namespace), slog.String("name", name), slog.String("error", err.Error()))
		return nil, fmt.Errorf("failed to get SecretClaim %s in namespace %s: %w", name, namespace, err)
	}
	span.SetStatus(codes.Ok, "Success")
	return secret, nil
}

func (m *K8sDynamicClient) GetActualSecret(ctx context.Context, name, namespace string) (*corev1.Secret, error) {
	ctx, span := m.Tracer.Start(ctx, "K8sDynamicClient.GetActualSecretData")
	defer span.End()

	m.Logger.Debug("K8s: attempting to get actual Secret data",
		slog.String("namespace", namespace),
		slog.String("name", name))

	span.SetAttributes(semconv.K8SNamespaceName(namespace))

	actualSecret := &corev1.Secret{}

	err := m.Client.Get(
		ctx,
		client.ObjectKey{Namespace: namespace, Name: name},
		actualSecret,
	)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Failed to get actual Secret")
		m.Logger.Error("K8s: failed to get actual Secret", slog.String("namespace", namespace), slog.String("name", name), slog.String("error", err.Error()))
		return nil, fmt.Errorf("failed to get native Secret %s: %w", name, err)
	}

	span.SetStatus(codes.Ok, "Success")
	return actualSecret, nil
}

func (m *K8sDynamicClient) ListSecretClaim(ctx context.Context, namespace string) (*secretsv1alpha1.SecretClaimList, error) {
	ctx, span := m.Tracer.Start(ctx, "K8sDynamicClient.ListSecretClaim")
	defer span.End()

	m.Logger.Debug("K8s: attempting to list SecretClaims",
		slog.String("namespace", namespace))

	span.SetAttributes(semconv.K8SNamespaceName(namespace))

	secretClaimList := &secretsv1alpha1.SecretClaimList{}
	err := m.Client.List(
		ctx,
		secretClaimList,
		client.InNamespace(namespace),
	)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Failed to list SecretClaims")
		m.Logger.Error("K8s: failed to list SecretClaims", slog.String("namespace", namespace), slog.String("error", err.Error()))
		return nil, fmt.Errorf("failed to list SecretClaims in namespace %s: %w", namespace, err)
	}
	span.SetStatus(codes.Ok, "Success")
	return secretClaimList, nil
}
