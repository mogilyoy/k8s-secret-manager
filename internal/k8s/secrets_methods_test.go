package k8s

import (
	"context"
	"fmt"
	"io"
	"log/slog"
	"reflect"
	"testing"

	secretsv1alpha1 "github.com/mogilyoy/k8s-secret-manager/api/v1alpha1"
	"github.com/mogilyoy/k8s-secret-manager/internal/api"
	"github.com/stretchr/testify/require"
	"go.opentelemetry.io/otel"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
)

func newTestK8sClient(t *testing.T) *K8sDynamicClient {
	t.Helper()

	scheme := runtime.NewScheme()
	require.NoError(t, corev1.AddToScheme(scheme))
	require.NoError(t, secretsv1alpha1.AddToScheme(scheme))

	cl := fake.NewClientBuilder().
		WithScheme(scheme).
		Build()

	logger := slog.New(slog.NewTextHandler(io.Discard, nil))

	tracer := otel.Tracer("test")

	return &K8sDynamicClient{
		Client: cl,
		Logger: logger,
		Tracer: tracer,
	}
}

func TestCreateSecretClaim_AutoGenerated_Success(t *testing.T) {
	ctx := context.Background()
	k := newTestK8sClient(t)

	name := "test-claim-auto"
	ns := "default"
	claimType := "AutoGenerated"

	data := map[string]string{"foo": "bar"}
	encoding := api.Alphanumeric
	keys := []string{"password", "token"}

	genCfg := &api.GenerationConfig{
		Length:   16,
		Encoding: &encoding,
		DataKeys: &keys,
	}

	labels := map[string]string{"app": "testing"}
	annotations := map[string]string{"custom": "annotation"}

	err := k.CreateSecretClaim(ctx, name, ns, claimType, &data, genCfg, &labels, &annotations)
	if err != nil {
		t.Fatalf("CreateSecretClaim error: %v", err)
	}

	var got secretsv1alpha1.SecretClaim
	if err := k.Client.Get(ctx, types.NamespacedName{Namespace: ns, Name: name}, &got); err != nil {
		t.Fatalf("getting SecretClaim failed: %v", err)
	}
	if got.Spec.Type != claimType {
		t.Errorf("Spec.Type = %v, want %v", got.Spec.Type, claimType)
	}
	if got.Spec.Generation == nil {
		t.Error("Spec.Generation is nil, want non-nil")
	} else {
		if got.Spec.Generation.Length != int(genCfg.Length) {
			t.Errorf("Generation.Length = %v, want %v", got.Spec.Generation.Length, genCfg.Length)
		}
		if got.Spec.Generation.Encoding != string(*genCfg.Encoding) {
			t.Errorf("Generation.Encoding = %v, want %v", got.Spec.Generation.Encoding, string(*genCfg.Encoding))
		}
		if !reflect.DeepEqual(got.Spec.Generation.DataKeys, *genCfg.DataKeys) {
			t.Errorf("Generation.DataKeys = %v, want %v", got.Spec.Generation.DataKeys, *genCfg.DataKeys)
		}
	}
	if got.Spec.Data != nil {
		t.Errorf("Spec.Data = %v, want nil for AutoGenerated", got.Spec.Data)
	}
	if got.Labels["app"] != labels["app"] {
		t.Errorf("Labels[app] = %v, want %v", got.Labels["app"], labels["app"])
	}
	if got.Annotations["custom"] != annotations["custom"] {
		t.Errorf("Annotations[custom] = %v, want %v", got.Annotations["custom"], annotations["custom"])
	}
}

func TestCreateSecretClaim_Opaque_Success(t *testing.T) {
	ctx := context.Background()
	k := newTestK8sClient(t)

	name := "test-claim-opaque"
	ns := "default"
	claimType := "Opaque"

	data := map[string]string{"foo": "bar"}

	err := k.CreateSecretClaim(ctx, name, ns, claimType, &data, nil, nil, nil)
	if err != nil {
		t.Fatalf("CreateSecretClaim error: %v", err)
	}

	var got secretsv1alpha1.SecretClaim
	if err := k.Client.Get(ctx, types.NamespacedName{Namespace: ns, Name: name}, &got); err != nil {
		t.Fatalf("getting SecretClaim failed: %v", err)
	}
	if got.Spec.Type != claimType {
		t.Errorf("Spec.Type = %v, want %v", got.Spec.Type, claimType)
	}
	if got.Spec.Generation != nil {
		t.Errorf("Spec.Generation = %v, want nil for Opaque", got.Spec.Generation)
	}
	if !reflect.DeepEqual(got.Spec.Data, data) {
		t.Errorf("Spec.Data = %v, want %v", got.Spec.Data, data)
	}
}

func TestCreateSecretClaim_InvalidGenerationConfig(t *testing.T) {
	ctx := context.Background()
	k := newTestK8sClient(t)

	name := "bad-claim"
	ns := "default"
	claimType := "AutoGenerated"

	genCfg := &api.GenerationConfig{
		Length:   4,
		Encoding: nil,
		DataKeys: nil,
	}

	err := k.CreateSecretClaim(ctx, name, ns, claimType, nil, genCfg, nil, nil)
	if err == nil {
		t.Fatalf("expected error due to invalid generationConfig, got nil")
	}

	var got secretsv1alpha1.SecretClaim
	err = k.Client.Get(ctx, types.NamespacedName{Namespace: ns, Name: name}, &got)
	if err == nil {
		t.Errorf("SecretClaim should not be created on invalid generationConfig")
	}
}

func TestUpdateSecretClaim_AutoGenerated_Success(t *testing.T) {
	ctx := context.Background()
	k := newTestK8sClient(t)

	name := "update-claim-auto"
	ns := "default"
	claimType := "AutoGenerated"

	original := &secretsv1alpha1.SecretClaim{
		ObjectMeta: metav1.ObjectMeta{Name: name, Namespace: ns},
		Spec: secretsv1alpha1.SecretClaimSpec{
			Type: "Opaque",
			Data: map[string]string{"foo": "bar"},
		},
	}
	if err := k.Client.Create(ctx, original); err != nil {
		t.Fatalf("setup: failed to create original SecretClaim: %v", err)
	}

	data := map[string]string{"foo": "baz"}
	encoding := api.Alphanumeric
	keys := []string{"password"}

	genCfg := &api.GenerationConfig{
		Length:   12,
		Encoding: &encoding,
		DataKeys: &keys,
	}

	labels := map[string]string{"app": "updated"}
	annotations := map[string]string{"updated": "true"}

	err := k.UpdateSecretClaim(ctx, name, ns, claimType, true, &data, genCfg, &labels, &annotations)
	if err != nil {
		t.Fatalf("UpdateSecretClaim error: %v", err)
	}

	var got secretsv1alpha1.SecretClaim
	if err := k.Client.Get(ctx, types.NamespacedName{Namespace: ns, Name: name}, &got); err != nil {
		t.Fatalf("getting updated SecretClaim failed: %v", err)
	}

	if got.Spec.Type != claimType {
		t.Errorf("Spec.Type = %v, want %v", got.Spec.Type, claimType)
	}
	if got.Spec.Generation == nil {
		t.Errorf("Spec.Generation is nil, want non-nil")
	} else {
		if got.Spec.Generation.Length != int(genCfg.Length) {
			t.Errorf("Generation.Length = %v, want %v", got.Spec.Generation.Length, genCfg.Length)
		}
		if got.Spec.Generation.Encoding != string(*genCfg.Encoding) {
			t.Errorf("Generation.Encoding = %v, want %v", got.Spec.Generation.Encoding, string(*genCfg.Encoding))
		}
		if !reflect.DeepEqual(got.Spec.Generation.DataKeys, *genCfg.DataKeys) {
			t.Errorf("Generation.DataKeys = %v, want %v", got.Spec.Generation.DataKeys, *genCfg.DataKeys)
		}
	}
	if got.Spec.Data != nil {
		t.Errorf("Spec.Data = %v, want nil for AutoGenerated", got.Spec.Data)
	}
	if got.Labels["app"] != labels["app"] {
		t.Errorf("Labels[app] = %v, want %v", got.Labels["app"], labels["app"])
	}
	if got.Annotations["updated"] != annotations["updated"] {
		t.Errorf("Annotations[updated] = %v, want %v", got.Annotations["updated"], annotations["updated"])
	}
}

func TestUpdateSecretClaim_Opaque_Success(t *testing.T) {
	ctx := context.Background()
	k := newTestK8sClient(t)

	name := "update-claim-opaque"
	ns := "default"

	original := &secretsv1alpha1.SecretClaim{
		ObjectMeta: metav1.ObjectMeta{Name: name, Namespace: ns},
		Spec: secretsv1alpha1.SecretClaimSpec{
			Type: "Opaque",
			Data: map[string]string{"foo": "bar"},
		},
	}
	if err := k.Client.Create(ctx, original); err != nil {
		t.Fatalf("setup: failed to create original SecretClaim: %v", err)
	}

	data := map[string]string{"foo": "baz"}
	claimType := "Opaque"

	err := k.UpdateSecretClaim(ctx, name, ns, claimType, false, &data, nil, nil, nil)
	if err != nil {
		t.Fatalf("UpdateSecretClaim error: %v", err)
	}

	var got secretsv1alpha1.SecretClaim
	if err := k.Client.Get(ctx, types.NamespacedName{Namespace: ns, Name: name}, &got); err != nil {
		t.Fatalf("getting updated SecretClaim failed: %v", err)
	}

	if got.Spec.Type != claimType {
		t.Errorf("Spec.Type = %v, want %v", got.Spec.Type, claimType)
	}
	if got.Spec.Generation != nil {
		t.Errorf("Spec.Generation = %v, want nil for Opaque", got.Spec.Generation)
	}
	if !reflect.DeepEqual(got.Spec.Data, data) {
		t.Errorf("Spec.Data = %v, want %v", got.Spec.Data, data)
	}
}

func TestUpdateSecretClaim_InvalidGenerationConfig(t *testing.T) {
	ctx := context.Background()
	k := newTestK8sClient(t)

	name := "update-bad-claim"
	ns := "default"

	original := &secretsv1alpha1.SecretClaim{
		ObjectMeta: metav1.ObjectMeta{Name: name, Namespace: ns},
		Spec: secretsv1alpha1.SecretClaimSpec{
			Type: "AutoGenerated",
			Generation: &secretsv1alpha1.GenerationConfig{
				Length:   16,
				Encoding: "base64",
				DataKeys: []string{"password"},
			},
		},
	}
	if err := k.Client.Create(ctx, original); err != nil {
		t.Fatalf("setup: failed to create original SecretClaim: %v", err)
	}

	claimType := "AutoGenerated"

	genCfg := &api.GenerationConfig{
		Length: 4,
	}

	err := k.UpdateSecretClaim(ctx, name, ns, claimType, false, nil, genCfg, nil, nil)
	if err == nil {
		t.Fatalf("expected error due to invalid generationConfig, got nil")
	}
}

func TestUpdateSecretClaim_SecretClaimNotFound(t *testing.T) {
	ctx := context.Background()
	k := newTestK8sClient(t)

	err := k.UpdateSecretClaim(ctx, "nonexistent", "default", "Opaque", false, nil, nil, nil, nil)
	if err == nil {
		t.Fatalf("expected error for missing SecretClaim, got nil")
	}
}

func TestDeleteSecretClaim_Success(t *testing.T) {
	ctx := context.Background()
	k := newTestK8sClient(t)

	name := "delete-claim"
	ns := "default"
	claim := &secretsv1alpha1.SecretClaim{
		ObjectMeta: metav1.ObjectMeta{Name: name, Namespace: ns},
		Spec:       secretsv1alpha1.SecretClaimSpec{Type: "Opaque"},
	}
	if err := k.Client.Create(ctx, claim); err != nil {
		t.Fatalf("setup: failed to create SecretClaim: %v", err)
	}

	err := k.DeleteSecretClaim(ctx, name, ns)
	if err != nil {
		t.Fatalf("DeleteSecretClaim error: %v", err)
	}

	var got secretsv1alpha1.SecretClaim
	err = k.Client.Get(ctx, types.NamespacedName{Namespace: ns, Name: name}, &got)
	if err == nil {
		t.Errorf("SecretClaim still exists after DeleteSecretClaim")
	}
}

func TestDeleteSecretClaim_NotFoundDoesNotError(t *testing.T) {
	ctx := context.Background()
	k := newTestK8sClient(t)

	err := k.DeleteSecretClaim(ctx, "nonexistent", "default")
	if err != nil {
		t.Fatalf("expected no error deleting nonexistent SecretClaim, got %v", err)
	}
}

// простой мок

type clientWithDeleteError struct {
	client.Client
	shouldError bool
}

func (c *clientWithDeleteError) Delete(ctx context.Context, obj client.Object, opts ...client.DeleteOption) error {
	if c.shouldError {
		return fmt.Errorf("forced delete error")
	}
	return c.Client.Delete(ctx, obj, opts...)
}

func TestDeleteSecretClaim_DeleteError(t *testing.T) {
	ctx := context.Background()

	scheme := runtime.NewScheme()
	if err := corev1.AddToScheme(scheme); err != nil {
		t.Fatalf("failed to add corev1 to scheme: %v", err)
	}
	if err := secretsv1alpha1.AddToScheme(scheme); err != nil {
		t.Fatalf("failed to add api scheme: %v", err)
	}

	baseClient := fake.NewClientBuilder().WithScheme(scheme).Build()
	errClient := &clientWithDeleteError{Client: baseClient, shouldError: true}

	k := &K8sDynamicClient{
		Client: errClient,
		Logger: slog.New(slog.NewTextHandler(io.Discard, &slog.HandlerOptions{})),
		Tracer: otel.Tracer("test"),
	}

	err := k.DeleteSecretClaim(ctx, "some-claim", "default")
	if err == nil {
		t.Fatalf("expected error from DeleteSecretClaim but got nil")
	}
}

func TestGetSecretClaim_Success(t *testing.T) {
	ctx := context.Background()
	k := newTestK8sClient(t)

	name := "test-claim"
	ns := "default"
	expected := &secretsv1alpha1.SecretClaim{
		ObjectMeta: metav1.ObjectMeta{Name: name, Namespace: ns},
		Spec:       secretsv1alpha1.SecretClaimSpec{Type: "Opaque"},
	}
	if err := k.Client.Create(ctx, expected); err != nil {
		t.Fatalf("setup: failed to create SecretClaim: %v", err)
	}

	got, err := k.GetSecretClaim(ctx, name, ns)
	if err != nil {
		t.Fatalf("GetSecretClaim error: %v", err)
	}
	if got.Name != expected.Name || got.Namespace != expected.Namespace {
		t.Errorf("got %v, want %v", got, expected)
	}
}

func TestGetSecretClaim_NotFound(t *testing.T) {
	ctx := context.Background()
	k := newTestK8sClient(t)

	_, err := k.GetSecretClaim(ctx, "nonexistent", "default")
	if err == nil {
		t.Fatalf("expected error for nonexistent SecretClaim, got nil")
	}
}

func TestGetActualSecret_Success(t *testing.T) {
	ctx := context.Background()
	k := newTestK8sClient(t)

	name := "test-secret"
	ns := "default"
	expected := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{Name: name, Namespace: ns},
		Data:       map[string][]byte{"key": []byte("value")},
	}
	if err := k.Client.Create(ctx, expected); err != nil {
		t.Fatalf("setup: failed to create Secret: %v", err)
	}

	got, err := k.GetActualSecret(ctx, name, ns)
	if err != nil {
		t.Fatalf("GetActualSecret error: %v", err)
	}
	if got.Name != expected.Name || got.Namespace != expected.Namespace {
		t.Errorf("got %v, want %v", got, expected)
	}
}

func TestGetActualSecret_NotFound(t *testing.T) {
	ctx := context.Background()
	k := newTestK8sClient(t)

	_, err := k.GetActualSecret(ctx, "nonexistent", "default")
	if err == nil {
		t.Fatalf("expected error for nonexistent Secret, got nil")
	}
}

func TestListSecretClaim_Success(t *testing.T) {
	ctx := context.Background()
	k := newTestK8sClient(t)

	ns := "default"

	// создаём несколько объектов в namespace default
	claim1 := &secretsv1alpha1.SecretClaim{
		ObjectMeta: metav1.ObjectMeta{Name: "claim1", Namespace: ns},
	}
	claim2 := &secretsv1alpha1.SecretClaim{
		ObjectMeta: metav1.ObjectMeta{Name: "claim2", Namespace: ns},
	}

	if err := k.Client.Create(ctx, claim1); err != nil {
		t.Fatalf("setup: failed to create claim1: %v", err)
	}
	if err := k.Client.Create(ctx, claim2); err != nil {
		t.Fatalf("setup: failed to create claim2: %v", err)
	}

	list, err := k.ListSecretClaim(ctx, ns)
	if err != nil {
		t.Fatalf("ListSecretClaim error: %v", err)
	}

	if list == nil {
		t.Fatalf("ListSecretClaim returned nil list")
	}
	if len(list.Items) != 2 {
		t.Errorf("expected 2 items, got %d", len(list.Items))
	}

	// Проверяем, что объекты из нужного namespace
	for _, item := range list.Items {
		if item.Namespace != ns {
			t.Errorf("unexpected namespace %v for item %v", item.Namespace, item.Name)
		}
	}
}

func TestListSecretClaim_Empty(t *testing.T) {
	ctx := context.Background()
	k := newTestK8sClient(t)

	ns := "empty-namespace"

	list, err := k.ListSecretClaim(ctx, ns)
	if err != nil {
		t.Fatalf("ListSecretClaim error: %v", err)
	}
	if list == nil {
		t.Fatalf("ListSecretClaim returned nil list")
	}
	if len(list.Items) != 0 {
		t.Errorf("expected 0 items, got %d", len(list.Items))
	}
}

// Для мокания ошибки List — аналогично паттерну с DeleteError,
// можно создать кастомный client.Client, который возвращает ошибку при вызове List.
// При желании могу помочь с примером.

func (c *clientWithDeleteError) List(ctx context.Context, obj client.ObjectList, opts ...client.ListOption) error {
	if c.shouldError {
		return fmt.Errorf("forced delete error")
	}
	return c.Client.List(ctx, obj, opts...)
}

func TestListSecretsClaim_DeleteError(t *testing.T) {
	ctx := context.Background()

	scheme := runtime.NewScheme()
	if err := corev1.AddToScheme(scheme); err != nil {
		t.Fatalf("failed to add corev1 to scheme: %v", err)
	}
	if err := secretsv1alpha1.AddToScheme(scheme); err != nil {
		t.Fatalf("failed to add api scheme: %v", err)
	}

	baseClient := fake.NewClientBuilder().WithScheme(scheme).Build()
	errClient := &clientWithDeleteError{Client: baseClient, shouldError: true}

	k := &K8sDynamicClient{
		Client: errClient,
		Logger: slog.New(slog.NewTextHandler(io.Discard, &slog.HandlerOptions{})),
		Tracer: otel.Tracer("test"),
	}

	_, err := k.ListSecretClaim(ctx, "default")
	if err == nil {
		t.Fatalf("expected error from ListSecretClaim but got nil")
	}
}
